#!/usr/bin/env bash

source "${HOME}/.bashrc"

if [[ -f "${HOME}/btn-autopack.cfg" ]]; then
    source "${HOME}/btn-autopack.cfg"
else
    echo "Configuration file ${HOME}/btn-autopack.cfg not found. Exiting."
    exit 1
fi

################################################
### Variables imported from configuration files
################################################
### BTN_PACKBASE_DIR - the base directory where packs are created.
###     A new directory is created here for packing the season.
### BTN_METAFILE_DIR - directory where rtorrent watches for metafiles.
###     Putting metafiles here will automatically start downloads.
### BTN_STAGING_DIR  - directory for created torrents and mediainfo.
### BTN_AUTHKEY      - authorization key.
### BTN_TORRENTPASS  - passkey for torrents.
### BTN_ANNOUNCE     - announce URL.
### BTN_SITEURL      - domain name of the website.
### BTN_METAFILE_STORE (optional) - directory where torrent
###     metafiles are stored after the packing is complete.
###     If empty, metafiles are removed.
### BTN_AUTOPACK_LOGDIR - directory where logs will be stored.
### BTN_AUTOPACK_TMPDIR - directory where temporary files will be stored.
################################################


_do_endscript() {
    echo "FAILED."
    exit 1
}


_is_debug() {
    [[ "$DEBUG_FLAG" == 1 ]]   || return 1
}


_is_verbose() {
    [[ "$VERBOSE_FLAG" == 1 ]] || return 1
}


function _filelog() {
    msg="${@}"
    echo "${msg}" | tee -a "${release_logfile}"
    _dbglog "${msg}"
}


function _vlog() {
    # this function always returns True
    { _is_verbose && _filelog "${@}"; } || return 0
}


function _dbglog() {
    # this function always returns True
    # this cannot go into the logfile because
    # we start debugging even before the logfile
    # is defined.
    { _is_debug && echo "${@}"; } || return 0
}


_is_metafile_ok() {
    if [[ -f "${1}" ]]; then
        lstor -qo __hash__ "${1}" | grep -q -v "Error" || return 1
    else
        return 1
    fi  
}


_has_array_value() {
	local needle="$1"   # Save first argument in a variable
	shift               # Shift all arguments to the left (original $1 gets lost)
	local haystack=("$@") # Rebuild the array with rest of arguments
	for value in "${haystack[@]}"; do
		if [[ "$value" == "$needle" ]]; then
			return 0
		fi
	done
	return 1
}


_get_torrent_url_from_id() {
    echo "${BTN_SITEURL}/torrents.php?action=download&id=${1}&authkey=${BTN_AUTHKEY}&torrent_pass=${BTN_TORRENTPASS}"
}


_download_metafile() {
    local tid
    local metafile
    local torrent_url
    #
    tid="${1}"
    metafile="${2}"
    # Debug and logs
    _dbglog "Downloading metafile for torrent ID ${tid}."
    #
    # BTN URL from torrent ID
    torrent_url=$( _get_torrent_url_from_id "${tid}" )
    #
    # Old metafiles may exist (e.g. during resubmitting a job)
    # If it is a download error (not a torrent file), remove. Keep otherwise.
    if [[ -f "${metafile}" ]]; then
        _dbglog "${metafile} exists."
        _is_metafile_ok "${metafile}" || { _vlog "Error in metafile. Remove and download again." && rm -f "${metafile}"; }
    fi
    #
    # The main download loop: 
    # curl following redirects.
    if [[ ! -f ${metafile} ]]; then
        _vlog "Download metafile from: "
        _vlog "    ${torrent_url}"
        if _is_verbose; then
            curl -JL "${torrent_url}" -o "${metafile}"
        else
            curl -JL "${torrent_url}" -o "${metafile}" --silent
        fi
    fi
    _is_metafile_ok "${metafile}" || return 1
}


_is_download_complete() {
    # How to check if download is complete for a given metafile?
    # There can be hundreds of ways to check.
    # Here, I use a simple hash check from client.
	local lhash="${1}"
	comp_pct=$( rtcontrol -qo 'done' hash="${lhash}" )
    [[ "${comp_pct}" == "100.0" ]] || return 1
}


_wait_till_dl_complete() {
	local lhash_array=( "$@" )
	local dl_complete_array=()
	for lhash in "${lhash_array[@]}"; do
		_is_download_complete "${lhash}" && dl_complete_array+=( "${lhash}" )
	done
	#------- some logging to show progreess ---------
	_vlog "Number of torrents to download: ${#lhash_array[@]}"
	_vlog "    Number of complete downloads: ${#dl_complete_array[@]}"
	# -----------------
	# loop until complete
	until [[ "${#lhash_array[@]}" == "${#dl_complete_array[@]}" ]]
	do
		_vlog "    Waiting for all downloads to complete ..."
		sleep 60
		for lhash in "${lhash_array[@]}"; do
			if ! _has_array_value "${lhash}" "${dl_complete_array[@]}"; then
				_dbglog "    ${lhash} : Check again"
				_is_download_complete "${lhash}" && dl_complete_array+=( "${lhash}" )
			else
				_dbglog "    ${lhash} : Already completed. Skip check."
			fi
		done
		_vlog "    Number of complete downloads: ${#dl_complete_array[@]}"
	done
}


#         x < 50MB  : 32kB 
# 50MB  < x < 150MB : 64kB
# 150MB < x < 350MB : 128kB
# 350MB < x < 512MB : 256kB
# 512MB < x < 1GB   : 512kB
# 1GB   < x < 2GB   : 1024kB
# 2GB   < x < 20GB  : 2048kB
# 20GB  < x         : 4096kB
# 
# Chunk size higher than 4MB is known to cause issues with rTorrent. 
# 
_get_chunk_size() {

    fname="${1}"
    fsize_arr=()
    if [[ -f "${fname}" ]]; then
        fsize=$( du -sh "${fname}" | cut -f1 | numfmt --from=iec )
        fsize_arr+=( "${fsize}" )
    else
        for f in "${fname}"/*; do
            fsize=$( du -sh "${f}" | cut -f1 | numfmt --from=iec )
            fsize_arr+=( "${fsize}" )
        done
    fi  

    min_fsize=${fsize_arr[0]}
    for i in "${fsize_arr[@]}"; do
        [[ ${i} -lt ${min_fsize} ]] && min_fsize=${i}
    done
    ## min_fsize_readable=$( echo ${min_fsize} | numfmt --to=iec )
    # convert filesize to MB
    fsize=$( echo "${min_fsize}" | awk ' {$1/=1048576; printf "%0.2f",$1} ' | cut -d'.' -f1)

    chunk_size="1024K"
    if [[ "${fsize}" -lt 50 ]]; then
        chunk_size="32K"
    elif [[ "${fsize}" -lt 150 ]]; then
        chunk_size="64K"
    elif [[ "${fsize}" -lt 350 ]]; then
        chunk_size="128K"
    elif [[ "${fsize}" -lt 512 ]]; then
        chunk_size="256K"
    elif [[ "${fsize}" -lt 1024 ]]; then
        chunk_size="512K"
    elif [[ "${fsize}" -lt 2048 ]]; then
        chunk_size="1024K"
    elif [[ "${fsize}" -lt 20480 ]]; then
        chunk_size="2048K"
    else
        chunk_size="4096K"
    fi  

    echo ${chunk_size}
}


_get_chunk_length() {
    local size
    local length
    size=$( numfmt --from=iec "${1}" )
    length=$( echo "l($size)/l(2)" | bc -l | cut -d'.' -f1 )
    echo "${length}"
}


_show_help() {
    exitcode=${1}
    if [[ ! -z "${2}" ]]; then
        echo "Error: ${2}"
        echo ""
    fi
    echo "btn-autopack: Download and pack seasons from BTN."
    echo "Usage:"
    echo "    btn-autopack [OPTIONS] -b <id1> <id2> ... -r <release_name> -d <directory_name>"
    echo "Flags:"
    echo "    -b | --btnid      list of torrent IDs from BTN"
    echo "    -r | --release    release name following BTN convention"
    echo "Options:"
    echo "    -d | --dir        name of the directory where episodes will be kept"
    echo "    -h | --help       show this help and exit"
    echo "    -v | --verbose    show detailed information"
    echo ""
    [[ $exitcode == 0 ]] && exit 0 || exit 1
}


DEBUG_FLAG=0
VERBOSE_FLAG=0
dateflag=$( date +"%Y-%m-%d" )

# Process arguments from command line
btnid_array=()
while [[ $# -gt 0 ]]; do
    key="${1}"
    _dbglog "Current key = ${1}"
    _dbglog "Next key = ${2}"
    case ${key} in
        "-b" | "--btnid")
            while [[ ! -z "${2}" && "${2}" != "-"* ]]; do
                _dbglog "  Key is ${2}. Grab!"
                btnid_array+=( "${2}" )
                shift
            done
            shift;;
        "-r" | "--release")
            release_name=${2}
            shift
            shift;;
        "-d" | "--dir")
            packdir_name=${2}
            shift
            shift;;
        "-v" | "--verbose")
            VERBOSE_FLAG=1
            shift;;
        "--debug")
            DEBUG_FLAG=1
            shift;;
        "-h" | "--help")
            _show_help 0;
            shift;;
        *)
            _show_help 1 "Wrong command"
            shift;;
    esac
done

#
# simple check if input is correct
#
_dbglog "${release_name}"
[[ ! -z "${release_name}" ]] || _show_help 1 "Please provide a release name"
[[ "${#btnid_array[@]}" -gt 1 ]] || _show_help 1 "Please provide more than one torrent IDs"

#
# setup logfile, tmpfile, etc
# create directories if required
#
mkdir -p "${BTN_AUTOPACK_LOGDIR}/${dateflag}"
release_logfile="${BTN_AUTOPACK_LOGDIR}/${dateflag}/${release_name}.log"
release_tempdir=$( mktemp --tmpdir="${BTN_AUTOPACK_TMPDIR}" -d "${release_name}".XXX )
# double quotes expands now rather than when signalled
trap "rm -rf ${release_tempdir}" EXIT INT QUIT TERM


# Create the requested directory for the season pack
if [[ -z "${packdir_name}" ]]; then
    _vlog "Using release name as directory"
    packdir_name="${release_name}"
fi
packdir_path="${BTN_PACKBASE_DIR}/${packdir_name}"
mkdir -p "${packdir_path}"

is_store_metafile=false
metastore_path=""
if [[ ! -z "${BTN_METAFILE_STORE}" ]]; then
	is_store_metafile=true
    metastore_path="${BTN_METAFILE_STORE}/${release_name}"
    [[ -d "${metastore_path}" ]] || mkdir -p "${metastore_path}"
fi

_filelog ""
_filelog "------------------------------"
_filelog "Release Name: ${release_name}"
_filelog "Target Directory: ${packdir_path}"
_filelog "Number of episodes: " "${#btnid_array[@]}"
_filelog "BTN Torrent IDs: " "${btnid_array[@]}"
_filelog "------------------------------"
_filelog ""

# Download the torrent metafiles from BTN
# in a temporary directory
_filelog "Downloading meta files from BTN."
mkdir -p "${release_tempdir}/metafiles"
metafile_array=()
for btnid in "${btnid_array[@]}"; do
    _dbglog "BTN Torrent ID: ${btnid}"
    metafile_path="${release_tempdir}/metafiles/${btnid}.torrent"
    _download_metafile "${btnid}" "${metafile_path}" || _do_endscript
    metafile_array+=( "${metafile_path}" )
done

# Put the torrent files in watch directory.
# This will automatically start the download.
# So, be careful not to download stuff twice.
_filelog "Sending meta files to rtorrent watch directory."
thash_array=()
for metafile in "${metafile_array[@]}"; do
    _dbglog "Check if file ${metafile} is already downloaded"
    thash=$( lstor -qo __hash__ "${metafile}" )
    thash_array+=( "${thash}" )
    { rtcontrol -qo 'is_open' hash="${thash}"; } || cp -f "${metafile}" "${BTN_METAFILE_DIR}"
done

_wait_till_dl_complete "${thash_array[@]}"


# Symlink when downloads are complete
_filelog "Link downloaded files to season pack directory."
for thash in "${thash_array[@]}"; do
	sourcepath=$( rtcontrol -qo 'path' hash="${thash}" )
	targetpath="${packdir_path}/"$( basename "${sourcepath}" )
	[[ -f "${targetpath}" ]] || ln "${sourcepath}" "${targetpath}" || _do_endscript
done


# Create torrent file using mktorrent
_filelog "Creating torrent file."
chunk_size=$( _get_chunk_size "${packdir_path}" )
chunk_length=$( _get_chunk_length "${chunk_size}" )
targetpath="${BTN_STAGING_DIR}/${release_name}.torrent"
[[ -f "${targetpath}" ]] && rm -f "${targetpath}"
_filelog "Calculated chunk size: ${chunk_size} | chunk piece length: ${chunk_length}"
mkcmd="mktorrent -p -t 16 -a ${BTN_ANNOUNCE} --comment=BTN -l ${chunk_length} -o ${targetpath}"
_is_verbose && mkcmd="${mkcmd} -v"
${mkcmd} "${packdir_path}" || _do_endscript


# Create mediainfo file for uploading
_filelog "Creating mediainfo file."
episode1_filename=$( lstor -qo info.name "${metafile_array[0]}" )
sourcepath="${packdir_path}/${episode1_filename}"
targetpath="${BTN_STAGING_DIR}/${release_name}.info"
[[ -f "${targetpath}" ]] && rm -f "${targetpath}"
mediainfo "${sourcepath}" >> "${targetpath}"


# Cleanup temporary directory containing metafiles
if [[ "${is_store_metafile}" == "true" ]]; then
    for metafile in "${metafile_array[@]}"; do
        cp "${metafile}" "${metastore_path}/"
    done
fi
rm -rf "${release_tempdir}"

_filelog "SUCCESS"
touch "${BTN_STAGING_DIR}/${release_name}.done"
exit 0
