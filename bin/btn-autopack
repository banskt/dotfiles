#!/usr/bin/env bash

if [[ -f ${HOME}/btn-autopack.cfg ]]; then
    source ${HOME}/btn-autopack.cfg
else
    echo "Configuration file ${HOME}/btn-autopack.cfg not found. Exiting."
    exit 1
fi

################################################
### Variables imported from configuration files
################################################
### BTN_PACKBASE_DIR - the base directory where packs are created.
###     A new directory is created here for packing the season.
### BTN_EPISODE_DIR - download directory for episodes
### BTN_METAFILE_DIR - download directory for torrent metafiles
### BTN_AUTHKEY - authorization key
### BTN_TORRENTPASS - passkey for torrents 
### BTN_ANNOUNCE - announce URL
### BTN_SITEURL - domain name of the website
### BTN_METAFILE_STORE (optional) - directory where torrent
###     metafiles are stored after the packing is complete.
################################################


_do_endscript() {
    echo "FAILED."
    exit 1
}


_is_debug() {
    [[ "$DEBUG_FLAG" == 1 ]]   || return 1
}


_is_verbose() {
    [[ "$VERBOSE_FLAG" == 1 ]] || return 1
}


function _vlog() {
    # this function always returns True
    { _is_verbose && echo "${@}"; } || return 0
}


function _dbglog() {
    # this function always returns True
    { _is_debug && echo "${@}"; } || return 0
}


_is_metafile_ok() {
    if [[ -f "${1}" ]]; then
        lstor -qo __hash__ "${1}" | grep -q -v "Error" || return 1
    else
        return 1
    fi  
}


_has_array_value() {
	local needle="$1"   # Save first argument in a variable
	shift               # Shift all arguments to the left (original $1 gets lost)
	local haystack=("$@") # Rebuild the array with rest of arguments
	for value in "${haystack[@]}"; do
		if [[ "$value" == "$needle" ]]; then
			return 0
		fi
	done
	return 1
}


_get_torrent_url_from_id() {
    echo "${BTN_SITEURL}/torrents.php?action=download&id=${1}&authkey=${BTN_AUTHKEY}&torrent_pass=${BTN_TORRENTPASS}"
}


_download_metafile() {
    local tid=${1}
    # Debug and logs
    _dbglog "Downloading metafile for torrent ID ${tid}."
    #
    # Set local variables
    local metafile="${BTN_METAFILE_DIR}/${tid}.torrent"
    local torrent_url=$( _get_torrent_url_from_id "${tid}" )
    #
    # During resubmission, old metafiles may exist.
    # If it is a download error (not a torrent file), remove. Keep otherwise.
    if [[ -f ${metafile} ]]; then
        _dbglog "${metafile} exists."
        _is_metafile_ok ${metafile} || { _vlog "Error in metafile. Remove and download again." && rm -f ${metafile}; }
    fi
    #
    # The main download loop: 
    # curl following redirects.
    if [[ ! -f ${metafile} ]]; then
        _vlog "Download metafile from: "
        _vlog "    ${torrent_url}"
        if _is_verbose; then
            curl -JL ${torrent_url} -o ${metafile}
        else
            curl -JL ${torrent_url} -o ${metafile} --silent
        fi
    fi
    _is_metafile_ok ${metafile} || return 1
}


_cleanup_metafile() {
    local tid="${1}"
	local metafile="${BTN_METAFILE_DIR}/${tid}.torrent"
    local backup_metafile="${BTN_METAFILE_STORE}/${tid}.torrent"
    if [[ -f "${metafile}" ]]; then
        # Store a copy of metafile
        cp "${metafile}" "${backup_metafile}"
        # Untie metafiles from client and delete
        local metahash="$( lstor -qo __hash__ "${metafile}" )"
        rtxmlrpc -q d.delete_tied "${metahash}"
    fi
}


_is_download_complete() {
    # How to check if download is complete for a given metafile?
    # There can be hundreds of ways to check.
    # Here, I use a simple hash check from client.
    local metafile="${BTN_METAFILE_DIR}/${1}.torrent"
    local metahash="$( lstor -qo __hash__ "${metafile}" )"
    local comphash="$( rtcontrol -qo "%(hash)s" is_complete=y hash=${metahash} )"
    _vlog "Check for ${metahash} of $( lstor -qo info.name "${metafile}" )"
    _vlog "    Found: ${comphash}"
    [[ "${metahash}" == "${comphash}" ]] || return 1
}


#         x < 50MB  : 32kB 
# 50MB  < x < 150MB : 64kB
# 150MB < x < 350MB : 128kB
# 350MB < x < 512MB : 256kB
# 512MB < x < 1GB   : 512kB
# 1GB   < x < 2GB   : 1024kB
# 2GB   < x < 20GB  : 2048kB
# 20GB  < x         : 4096kB
# 
# Chunk size higher than 4MB is known to cause issues with rTorrent. 
# 
_get_chunk_size() {

    fsize_arr=()
    if [[ -f ${1} ]]; then
        fsize=$( du -sh ${1} | cut -f1 | numfmt --from=iec )
        fsize_arr+=( "${fsize}" )
    else
        for f in $( ls -1 ${1}/ ); do
            fsize=$( du -sh ${1}/${f} | cut -f1 | numfmt --from=iec )
            fsize_arr+=( "${fsize}" )
        done
    fi  

    min_fsize=${fsize_arr[0]}
    for i in ${fsize_arr[@]}; do
        [[ ${i} -lt ${min_fsize} ]] && min_fsize=${i}
    done
    ## min_fsize_readable=$( echo ${min_fsize} | numfmt --to=iec )
    # convert filesize to MB
    fsize=$( echo "${min_fsize}" | awk ' {$1/=1048576; printf "%0.2f",$1} ' | cut -d'.' -f1)

    chunk_size="1024K"
    if [[ "${fsize}" -lt 50 ]]; then
        chunk_size="32K"
    elif [[ "${fsize}" -lt 150 ]]; then
        chunk_size="64K"
    elif [[ "${fsize}" -lt 350 ]]; then
        chunk_size="128K"
    elif [[ "${fsize}" -lt 512 ]]; then
        chunk_size="256K"
    elif [[ "${fsize}" -lt 1024 ]]; then
        chunk_size="512K"
    elif [[ "${fsize}" -lt 2048 ]]; then
        chunk_size="1024K"
    elif [[ "${fsize}" -lt 20480 ]]; then
        chunk_size="2048K"
    else
        chunk_size="4096K"
    fi  

    echo ${chunk_size}
}


_get_chunk_length() {
    local size=$( numfmt --from=iec ${1} )
    local length=$( echo "l($size)/l(2)" | bc -l | cut -d'.' -f1 )
    echo ${length}
}


_show_help() {
    exitcode=${1}
    if [[ ! -z "${2}" ]]; then
        echo "Error: ${2}"
        echo ""
    fi
    echo "btn-autopack: Download and pack seasons from BTN."
    echo "Usage:"
    echo "    btn-autopack [OPTIONS] -b <id1> <id2> ... -r <release_name> -d <directory_name>"
    echo "Flags:"
    echo "    -b | --btnid      list of torrent IDs from BTN"
    echo "    -r | --release    release name following BTN convention"
    echo "Options:"
    echo "    -d | --dir        name of the directory where episodes will be kept"
    echo "    -h | --help       show this help and exit"
    echo "    -v | --verbose    show detailed information"
    echo ""
    [[ $exitcode == 0 ]] && exit 0 || exit 1
}


# Current default is verbose and debug.
# After using this a few more times, I can turn them off.
DEBUG_FLAG=0
VERBOSE_FLAG=0

# Process arguments from command line
btnid_array=()
while [[ $# -gt 0 ]]; do
    key=${1}
    _dbglog "Current key = ${1}"
    _dbglog "Next key = ${2}"
    case ${key} in
        "-b" | "--btnid")
            while [[ ! -z "${2}" && "${2}" != "-"* ]]; do
                _dbglog "  Key is ${2}. Grab!"
                btnid_array+=( "${2}" )
                shift
            done
            shift;;
        "-r" | "--release")
            release_name=${2}
            shift
            shift;;
        "-d" | "--dir")
            packdir_name=${2}
            shift
            shift;;
        "-v" | "--verbose")
            VERBOSE_FLAG=1
            shift;;
        "--debug")
            DEBUG_FLAG=1
            shift;;
        "-h" | "--help")
            _show_help 0;
            shift;;
        *)
            _show_help 1 "Wrong command"
            shift;;
    esac
done

_dbglog ${release_name}

[[ ! -z "${release_name}" ]] || _show_help 1 "Please provide a release name"
[[ "${#btnid_array[@]}" -gt 1 ]] || _show_help 1 "Please provide more than one torrent IDs"

if [[ -z "${packdir_name}" ]]; then
    _vlog "Using release name as directory"
    packdir_name="${release_name}"
fi

if [[ -z "${BTN_METAFILE_STORE}" ]]; then
	BTN_METAFILE_STORE="${BTN_METAFILE_DIR}/loaded"
    [[ -d ${BTN_METAFILE_STORE} ]] || mkdir -p ${BTN_METAFILE_STORE}
fi

echo ""
echo "------------------------------"
echo "Release Name: ${release_name}"
echo "Target Directory: ${packdir_name}"
echo "Number of episodes: ${#btnid_array[@]}"
echo "BTN Torrent IDs: ${btnid_array[@]}"
echo "------------------------------"
echo " "

# Download the torrents from BTN and put them in watch directory
# This will automatically start the download
echo "Downloading meta files from BTN."
for btnid in ${btnid_array[@]}; do
    _dbglog "BTN Torrent ID: ${btnid}"
    _download_metafile ${btnid} || _do_endscript
done

# Create the requested directory
[[ -d "${BTN_PACKBASE_DIR}/${packdir_name}" ]] || mkdir -p "${BTN_PACKBASE_DIR}/${packdir_name}"

# Watch the episode download directory and symlink when 
# download completes
# This checking loop could be put in a separate function
# but requires some array arguments to be passed around.
# So, it stays here for now.
# ------------ BEGIN CHECK --------------------------------
dl_complete_array=()
for btnid in ${btnid_array[@]}; do
    if ! _has_array_value "${btnid}" "${dl_complete_array[@]}"; then
        _is_download_complete "${btnid}" && dl_complete_array+=( "${btnid}"  )
    fi
done

_dbglog "Number of complete torrents: ${#dl_complete_array[@]}"
_dbglog "Complete torrents: ${dl_complete_array[@]}"

until [[ "${#btnid_array[@]}" == "${#dl_complete_array[@]}" ]]
do
    echo "Download completed for: ${dl_complete_array[@]}"
    echo "Waiting for other downloads to complete ..."
    sleep 30
	#--- update after sleeping --
	for btnid in ${btnid_array[@]}; do
        _dbglog "Check ${btnid} in ${dl_complete_array[@]} | if not present, call rtorrent"
        if ! _has_array_value "${btnid}" "${dl_complete_array[@]}"; then
            _is_download_complete "${btnid}" && dl_complete_array+=( "${btnid}"  )
        fi
	done
done
echo "All downloads are complete."
# ------------ END CHECK --------------------------------

echo "Link downloaded files to new upload directory."
for btnid in ${btnid_array[@]}; do
    episode_filename=$( lstor -qo info.name "${BTN_METAFILE_DIR}/${btnid}.torrent" )
    sourcefile="${BTN_EPISODE_DIR}/${episode_filename}"
    targetfile="${BTN_PACKBASE_DIR}/${packdir_name}/${episode_filename}"
    [[ -f "${targetfile}" ]] || ln "${sourcefile}" "${targetfile}" || _do_endscript
done

echo "Creating new torrent file."
chunk_size=$( _get_chunk_size ${BTN_PACKBASE_DIR}/${packdir_name} )
chunk_length="$( _get_chunk_length ${chunk_size} )"
echo "Calculated chunk size: ${chunk_size} | chunk piece length: ${chunk_length}"
#
# using mktorrent
mkcmd="mktorrent -p -t 16 -a ${BTN_ANNOUNCE} --comment=BTN -l ${chunk_length} -o ${BTN_PACKBASE_DIR}/${release_name}.torrent"
_is_verbose && mkcmd="${mkcmd} -v"
#
# or mktor
# mkcmd="mktor --private --comment=BTN -o ${BTN_PACKBASE_DIR}/${release_name}.torrent --chunk-min=${chunk_size} --chunk-max=${chunk_size}"
# _is_verbose && mkcmd="${mkcmd} -v" || mkcmd="${mkcmd} -q"
#
# Remove any old torrent if present
[[ -f ${BTN_PACKBASE_DIR}/${release_name}.torrent ]] && rm -f ${BTN_PACKBASE_DIR}/${release_name}.torrent
#
# Create the torrent.
${mkcmd} ${BTN_PACKBASE_DIR}/${packdir_name} || _do_endscript
#${mkcmd} ${BTN_PACKBASE_DIR}/${packdir_name} ${BTN_ANNOUNCE} || _do_endscript

echo "Cleaning up metafiles."
for btnid in ${btnid_array[@]}; do
	_cleanup_metafile ${btnid} || _do_endscript
done

echo "SUCCESS"
exit 0
