#!/usr/bin/env bash

# If this file is sourced, then source the functions and exit.
# Otherwise, run the commands
(return 0 2>/dev/null) && is_sourced=1 || is_sourced=0

function e_header()   { echo -e "\n\033[1m$@\033[0m"; }
function e_success()  { echo -e " \033[1;32m✔\033[0m  $@"; }
function e_error()    { echo -e " \033[1;31m✖\033[0m  $@"; }
function e_warning()  { echo -e " \033[1;33m!\033[0m  $@"; }
function e_arrow()    { echo -e " \033[1;34m➜\033[0m  $@"; }

#
#
# Pseudocode:
# if cover image exists
#     copy cover.img -> cover-orig.img
#     convert cover-orig.img -> cover.img
# else
#     if single image in folder
#         convert folder.img -> cover.img
#     elif multiple images in folder
#         show image names, let user select
#         convert folder.img -> cover.img
#     else 
#         show images in subdirectories, let user select
#         convert folder.img -> cover.img
_setcoverimage() {
    local albumpath
    local do_replace
    albumpath="$( realpath "${1}" )"
    #
    # resolve image properties
    imagepath="$( realpath "${2}" )"
    imagename="$( basename "${imagepath}" )"
    imagedir="$( dirname "${imagepath}" )"
    imageprefix="${imagename%.*}"
    imageext="${imagename##*.}"
    imagesize="$( du -b "${imagepath}" | awk '{print $1}' )"
    #
    # target cover image
    coverimage="${albumpath}/Cover.jpg"
    #
    # whether to replace original image
    do_replace="${3:-0}"
    #
    # do not replace
    if [[ "${do_replace}" == "0" ]]; then
        if [[ ! -f "${coverimage}" ]]; then
            _optimizeimage "${imagepath}" "${coverimage}"
        else
            # the cover image already exists
            # back it up and create new cover
            mkdir -p "${albumpath}/CoverImage_Original"
            bkpfile="${albumpath}/CoverImage_Original/Cover.$( date +'%Y.%m.%d-%H%M' ).jpg"
            mv "$coverimage" "${bkpfile}"
            # did we just backup the source image?
            if [[ "${coverimage}" == "${imagepath}" ]]; then
                _optimizeimage "${bkpfile}" "${coverimage}"
            else
                _optimizeimage "${imagepath}" "${coverimage}"
            fi
        fi
    # do replace
    else
        echo "WARNING: Replacing original image!"
        tempimage="$( mktemp -t cover_image.XXXXXXX.jpg )"
        trap "rm -f \"${tempimage}\"" EXIT INT QUIT TERM
        _optimizeimage "${imagepath}" "${tempimage}"
        mv "${tempimage}" "${coverimage}"
    fi
}

_optimizeimage() {
    local srcimg
    local tgtimg
    srcimg="${1}"
    tgtimg="${2}"
    convert "${srcimg}" -resize 1200x1200 -strip -quality 86 -auto-level -depth 8 "${tgtimg}"
}


_action_user_response_single_image() {
    local user_response
    local albumpath
    local coverimage
    albumpath="${1}"
    coverimage="${2}"
    if [[ ! "${is_skip_all}" == "true" ]]; then
        e_arrow "Do you want to fix? [y] yes [n] no [s] skip all"
        read -p "Enter one option: " user_response 0</dev/tty
        [[ "${user_response}" == "s" ]] && is_skip_all="true"
        [[ "${user_response}" == "y" ]] && _setcoverimage "${albumpath}" "${coverimage}"
        [[ "${user_response}" == "d" ]] && _action_user_response_choose_image "${albumpath}"
    fi
}


_action_user_response_choose_image() {
    local albumpath
    local images
    local image
    local imagesize
    local imagedims
    local whichimage
    local user_response
    local i
    albumpath="${1}"
    if [[ ! "${is_skip_all}" == "true" ]]; then
        readarray -t images < <(_findimages "${albumpath}")
        if [[ "${#images[@]}" == 0 ]]; then
            e_arrow "No image found. Check manually."
        else
            let i=1
            for image in "${images[@]}"; do
                imagename="$( realpath "${image}" --relative-to="${albumpath}" )"
                imagesize="$( du -sh "${image}" | awk '{print $1}' )"
                imagedims="$( identify -format '%wx%h' "${image}" 2>/dev/null )"
                echo "$((i++))  ${imagename} | ${imagesize} | ${imagedims}"
            done
            echo "Type s to skip all"
            read -p "Choose an image for cover: " user_response 0</dev/tty
            let i=1 
            whichimage=""
            for image in "${images[@]}"; do
                [[ "${user_response}" == "$(( i++ ))" ]] && whichimage="${image}"
            done
            [[ "${user_response}" == "s" ]] && is_skip_all="true"
            if [[ ! -z "${whichimage}" ]]; then
                e_arrow "Do you want to keep original? [y] Keep [n] Replace"
                read -p "Enter one option: " user_response 0</dev/tty
                [[ "${user_response}" == "n" ]] && _setcoverimage "${albumpath}" "${whichimage}" 1
                [[ "${user_response}" == "y" ]] && _setcoverimage "${albumpath}" "${whichimage}"
            fi
        fi
    fi
}


_findimages() {
    local albumpath
    albumpath="${1}"
    find "${albumpath}" -mindepth 1 -maxdepth 1 -type f \
        -exec bash -c '[[ "$( file -bi "$1" )" == *image* ]]' bash {} \; -printf "%p\n"
}


_action_interactive_coverimage() {
    local albumpath
    local albumname
    local coverimages
    local coverimage
    local otherimages
    local otherimage
    albumpath="$( realpath "${1}" )"
    albumname="$( basename "${albumpath}" )"
    # Check for existing images in directory
    #
    readarray -t coverimages < <(find "${albumpath}" -mindepth 1 -maxdepth 1 -name "Cover.*" -printf "%p\n")
    if [[ "${#coverimages[@]}" == 1 ]]; then
        # cover image exists
        # check size and dimension
        coverimage="${coverimages[0]}"
        coverimagesize="$( du -b "${coverimage}" | awk '{print $1}' )"
        # e_success "${albumname}: Found $( basename "${coverimage}" )"
        if [[ "${coverimagesize}" -le 1048576 ]]; then
            if grep -q "^1200$" < <(identify -format '%w\n%h' "${coverimage}" 2>/dev/null ); then
                e_success "${albumname} : Cover exists"
            else
                e_error "${albumname} :"
                echo "    Found $( basename "${coverimage}" ) with wrong dimension: $( identify -format '%wx%h' "${coverimage}" 2>/dev/null )"
                _action_user_response_single_image "${albumpath}" "${coverimage}"
            fi
        else
            e_error "${albumname} :"
            echo "    Found $( basename "${coverimage}" ) with large size: $( du -sh "${coverimage}" | awk '{print $1}' )"
            _action_user_response_single_image "${albumpath}" "${coverimage}"
        fi
    else
        e_error "${albumname}: No cover image found."
        _action_user_response_choose_image "${albumpath}"
    fi
}

# =================================================
# EXIT now if sourced, else continue
# =================================================
[[ "$is_sourced" == 1 ]] && return

srcdir="$( realpath "${1}" )"
is_recursive="${2:-1}"
is_skip_all="false"

if [[ "${is_recursive}" == 1 ]]; then
    e_header "${srcdir}"
    readarray -t albums < <(find "${srcdir}" -mindepth 1 -maxdepth 1 -type d -printf "%p\n")
    for ((j = 0; j < ${#albums[@]}; j++)); do
        _action_interactive_coverimage "${albums[j]}"
    done
else
    _action_interactive_coverimage "${srcdir}"
fi
